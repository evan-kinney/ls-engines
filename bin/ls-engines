#!/usr/bin/env node

/* eslint no-param-reassign: 0 */

'use strict';

const path = require('path');
const Semver = require('semver');
const { default: intersect } = require('fast_array_intersect');
const colors = require('colors/safe');
const yargs = require('yargs');
const jsonFile = require('json-file-plus');

const EXITS = require('../exit-codes');
const checkCurrent = require('../checkCurrent');
const checkEngines = require('../checkEngines');
const getLatestMajors = require('../getLatestMajors');

const FALSE = Object(false);
const TRUE = Object(true);

const argv = yargs
	.option('mode', {
		choices: ['auto', 'actual', 'virtual', 'ideal'],
		default: 'auto',
		describe: `”actual“ reads from \`${colors.gray('node_modules')}\`; ”virtual“ reads from a lockfile; “ideal” reads from \`${colors.gray('package.json')}\``,
	})
	.option('production', {
		default: TRUE,
		describe: 'whether to include production deps or not',
		type: 'boolean',
	})
	.option('dev', {
		default: FALSE,
		describe: 'whether to include dev deps or not',
		type: 'boolean',
	})
	.option('peer', {
		default: FALSE,
		describe: 'whether to include peer deps or not',
		type: 'boolean',
	})
	.option('save', {
		default: false,
		describe: `update \`${colors.gray('package.json')}\`’s “engines” field to match that of your dependency graph`,
		type: 'boolean',
	})
	.option('current', {
		default: TRUE,
		describe: 'check that the current node version matches your dependency graph’s requirements',
		type: 'boolean',
	})
	.check(({ dev, production, peer, current }) => {
		/* eslint no-throw-literal: 0 */
		if (![dev, production, peer].some((x) => x === TRUE || x === true)) {
			throw 'At least one of `--dev`, `--production`, or `--peer` must be enabled.';
		}
		if (current && dev) {
			if (current !== TRUE) {
				throw '`--current` is not available when checking dev deps.';
			}
		}
		return true;
	})
	.middleware(({ dev, production, peer, current, ...args }) => {
		if (typeof dev === 'object') {
			dev = Boolean.prototype.valueOf.call(dev);
		}
		if (typeof production === 'object') {
			production = Boolean.prototype.valueOf.call(production);
		}
		if (typeof peer === 'object') {
			peer = Boolean.prototype.valueOf.call(peer);
		}
		if (typeof current === 'object') {
			current = !dev && Boolean.prototype.valueOf.call(current);
		}
		return { ...args, current, dev, peer, production };
	})
	.strict()
	.help()
	.parse();

const { current, dev, mode, peer, production, save } = argv;

const getTree = require('get-dep-tree');
const getNodeVersions = require('../get-node-versions');

const selectedEngines = ['node'];

const pPackage = jsonFile(path.join(process.cwd(), 'package.json'));

const graphRanges = getTree(mode, { dev, peer, production }).then(async (tree) => {
	const graph = Array.from(
		tree.inventory.filter(({ package: { engines }, edgesIn, dev: isDev }) => (isDev ? dev : production) && edgesIn.size > 0 && engines && engines.node),
		({ name, package: { engines: { node } } }) => node && [name, node],
	).filter(([, node] = []) => node && node !== '*');

	return graph;
});

function caret(ver) {
	return `^${ver.replace(/^v/g, '')}`;
}

const pAllVersions = getNodeVersions().then((nodeVersions) => ({
	node: nodeVersions,
}));

Promise.all([pAllVersions, graphRanges, pPackage]).then(async ([allVersions, graph, pkg]) => {
	const rootNode = (pkg.data.engines && pkg.data.engines.node) || '*';

	const rootValids = allVersions.node.filter((v) => Semver.satisfies(v, rootNode));
	const graphAllowed = graph.map(([n, r]) => [
		n,
		allVersions.node.filter((v) => Semver.satisfies(v, r)),
	]);
	const graphValids = graph.length > 0 ? intersect(graphAllowed.map(([, vs]) => vs)) : allVersions.node;
	const validMajorRanges = graph.length > 0 ? graphValids.reduceRight((prev, v) => {
		prev = [].concat(prev);
		return Semver.satisfies(v, caret(prev[prev.length - 1])) ? prev : prev.concat(v);
	}).map(caret) : ['*'];
	const validRange = new Semver.Range(validMajorRanges.join(' || '));
	if (!graphValids.every((v) => validRange.test(v))) {
		throw new RangeError(`please report this: ${graphValids.join(',')} / ${validRange}`);
	}
	// console.log('*', graphAllowed.filter(([x, vs]) => !vs.some((v) => v.startsWith('v14'))));

	const displayRange = validRange.raw && validRange.raw.replace(/(?:\.0)+(?<x> |$)/g, '$<x>').split(' ').reverse().join(' ');
	if (validRange.raw) {
		console.log(colors.gray(`\nValid node version range: ${displayRange}`));
		const latestMajors = getLatestMajors(allVersions.node, validRange);
		console.log(colors.bold(colors.gray(`\nCurrently available latest releases of each valid node major version: ${latestMajors.join(', ')}`)));
	}

	// TODO: refactor to make rootValids/graphValids an object of engines
	const pEngines = checkEngines(
		selectedEngines,
		rootNode,
		{ node: rootValids },
		{ node: graphValids },
		{ node: graphAllowed },
		displayRange,
		save,
	);

	// TODO: refactor to make rootValids/graphValids an object of engines
	const pCurrent = current ? checkCurrent(selectedEngines, { node: rootValids }, { node: graphValids }) : { output: [] };

	// print out successes first
	const results = await Promise.allSettled([pEngines, pCurrent]);
	const fulfilleds = results.filter(({ status }) => status === 'fulfilled');
	const rejecteds = results.filter(({ status }) => status === 'rejected');

	fulfilleds.reduce(async (prev, { value: { output, save: doSave } }) => {
		await prev;

		output.forEach((line) => {
			console.log(line);
		});
		if (save && doSave) {
			doSave(pkg.data);
			try {
				await pkg.save();
			} catch {
				process.exitCode |= EXITS.SAVE;
			}
		}
	}, Promise.resolve());

	// print out failures last
	await rejecteds.reduce(async (prev, error) => {
		await prev;

		if (!error || !error.reason) {
			throw error;
		}
		const { reason } = error;
		const { code, output, save: doSave } = reason;
		if (!output) {
			throw reason;
		}

		if (save && doSave) {
			doSave(pkg.data);
			try {
				await pkg.save();
			} catch {
				process.exitCode |= EXITS.SAVE;
			}
		} else {
			process.exitCode |= code;
		}
		output.forEach((line) => {
			console.error(line);
		});
	}, Promise.resolve());
}).catch((e) => {
	console.error((e && e.stack) || e);
	process.exitCode |= EXITS.ERROR;
});
