#!/usr/bin/env node

/* eslint no-param-reassign: 0 */
/* eslint no-throw-literal: 0 */

'use strict';

const path = require('path');
const Semver = require('semver');
const { default: intersect } = require('fast_array_intersect');
const colors = require('colors/safe');
const yargs = require('yargs');
const jsonFile = require('json-file-plus');

const EXITS = require('../exit-codes');
const checkCurrent = require('../checkCurrent');

const FALSE = Object(false);
const TRUE = Object(true);

const argv = yargs
	.option('mode', {
		choices: ['auto', 'actual', 'virtual', 'ideal'],
		default: 'auto',
		describe: `”actual“ reads from \`${colors.gray('node_modules')}\`; ”virtual“ reads from a lockfile; “ideal” reads from \`${colors.gray('package.json')}\``,
	})
	.option('production', {
		default: TRUE,
		describe: 'whether to include production deps or not',
		type: 'boolean',
	})
	.option('dev', {
		default: FALSE,
		describe: 'whether to include dev deps or not',
		type: 'boolean',
	})
	.option('peer', {
		default: FALSE,
		describe: 'whether to include peer deps or not',
		type: 'boolean',
	})
	.option('save', {
		default: false,
		describe: `update \`${colors.gray('package.json')}\`’s “engines” field to match that of your dependency graph`,
		type: 'boolean',
	})
	.option('current', {
		default: TRUE,
		describe: 'check that the current node version matches your dependency graph’s requirements',
		type: 'boolean',
	})
	.check(({ dev, production, peer, current }) => {
		if (![dev, production, peer].some((x) => x === TRUE || x === true)) {
			throw 'At least one of `--dev`, `--production`, or `--peer` must be enabled.';
		}
		if (current && dev) {
			if (current !== TRUE) {
				throw '`--current` is not available when checking dev deps.';
			}
		}
		return true;
	})
	.middleware(({ dev, production, peer, current, ...args }) => {
		if (typeof dev === 'object') {
			dev = Boolean.prototype.valueOf.call(dev);
		}
		if (typeof production === 'object') {
			production = Boolean.prototype.valueOf.call(production);
		}
		if (typeof peer === 'object') {
			peer = Boolean.prototype.valueOf.call(peer);
		}
		if (typeof current === 'object') {
			current = !dev && Boolean.prototype.valueOf.call(current);
		}
		return { ...args, current, dev, peer, production };
	})
	.strict()
	.help()
	.parse();

const { current, dev, mode, peer, production, save } = argv;

const getTree = require('get-dep-tree');
const getNodeVersions = require('../get-node-versions');

const selectedEngines = ['node'];

const pPackage = jsonFile(path.join(process.cwd(), 'package.json'));

const graphRanges = getTree(mode, { dev, peer, production }).then(async (tree) => {
	const graph = Array.from(
		tree.inventory.filter(({ package: { engines }, edgesIn, dev: isDev }) => (isDev ? dev : production) && edgesIn.size > 0 && engines && engines.node),
		({ name, package: { engines: { node } } }) => node && [name, node],
	).filter(([, node] = []) => node && node !== '*');

	return graph;
});

function caret(ver) {
	return `^${ver.replace(/^v/g, '')}`;
}

const pAllVersions = getNodeVersions().then((nodeVersions) => ({
	node: nodeVersions,
}));

function isSubset(inner, outer) {
	const outerS = new Set(outer);
	return inner.every((item) => outerS.has(item));
}

async function checkEngines(rootNode, rootValids, graphValids, graphAllowed, displayRange, shouldSave) {
	const fixMessage = shouldSave
		? `\n\`${colors.gray('ls-engines')}\` will automatically fix this, per the \`${colors.gray('--save')}\` option, by adding the following to your \`${colors.gray('package.json')}\`:`
		: `\nYou can fix this by running \`${colors.bold(colors.gray('ls-engines --save'))}\`, or by manually adding the following to your \`${colors.gray('package.json')}\`:`;
	if (rootNode === '*') {
		throw {
			code: EXITS.IMPLICIT,
			output: [
				colors.bold(colors.red('\nYour “engines” field is either missing, or set to `{ "node": "*" }`! Prefer explicitly setting a supported engine range.')),
				fixMessage,
				colors.blue(`"engines": ${JSON.stringify({ node: displayRange }, null, 2)}`),
			],
			save(pkg) {
				if (!pkg.engines) {
					pkg.engines = {};
				}
				pkg.engines.node = displayRange;
			},
		};
	}
	const same = [];
	const subset = [];
	const superset = [];
	const conflicting = {};
	selectedEngines.forEach((engine) => {
		const all = new Set(rootValids[engine].concat(graphValids[engine]));
		const isSame = all.size === rootValids[engine].length && all.size === graphValids[engine].length;
		const rootIsSubsetOfGraph = isSubset(rootValids[engine], graphValids[engine]);
		const graphIsSubsetOfRoot = isSubset(graphValids[engine], rootValids[engine]);
		if (isSame) {
			same.push(engine);
			conflicting[engine] = [];
		} else {
			const packageInvalids = graphAllowed[engine]
				.filter(([, vs]) => !rootValids[engine].every((v) => vs.includes(v)))
				.map(([name, vs]) => [name, rootValids[engine].filter((v) => !vs.includes(v))]);
			conflicting[engine] = packageInvalids;

			if (graphIsSubsetOfRoot) {
				superset.push(engine);
			} else if (rootIsSubsetOfGraph) {
				subset.push(engine);
			}
		}
	});
	if (same.length === selectedEngines.length) {
		return {
			output: [
				colors.bold(colors.green('\nYour “engines” field exactly matches your dependency graph’s requirements!')),
			],
		};
	}

	if (superset.length > 0 || subset.length > 0) {
		const expandMessage = shouldSave
			? `\n\`${colors.gray('ls-engines')}\` will automatically ${superset.length > 0 ? 'narrow' : 'widen'} your support, per the \`${colors.gray('--save')}\` option, by adding the following to your \`${colors.gray('package.json')}\`:`
			: `\nIf you want to ${superset.length > 0 ? 'narrow' : 'widen'} your support, you can run \`${colors.bold(colors.gray('ls-engines --save'))}\`, or manually add the following to your \`${colors.gray('package.json')}\`:`;

		const result = {
			code: superset.length > 0 ? EXITS.INEXACT : EXITS.SUCCESS,
			output: [].concat(
				colors.bold(colors[superset.length > 0 ? 'yellow' : 'green'](`\nYour “engines” field allows ${superset.length > 0 ? 'more' : 'fewer'} node versions than your dependency graph does.`)),
				conflicting.node.length > 0 ? `\n${colors.gray(`Conflicting dependencies: ${conflicting.node.map(([name]) => name).join(', ')}`)}` : [],
				expandMessage,
				colors.blue(`"engines": ${JSON.stringify({ node: displayRange }, null, 2)}`),
			),
			save(pkg) {
				/* eslint no-param-reassign: 0 */
				if (!pkg.engines) {
					pkg.engines = {};
				}
				pkg.engines.node = displayRange;
			},
		};
		if (result.code !== EXITS.SUCCESS) {
			throw result;
		}
		return result;
	}
	throw {
		code: EXITS.INEXACT,
		output: [
			colors.red('\nYour “engines” field does not exactly match your dependency graph‘s requirements!'),
			fixMessage,
			colors.blue(`"engines": ${JSON.stringify({ node: displayRange }, null, 2)}`),
		],
		save(pkg) {
			/* eslint no-param-reassign: 0 */
			if (!pkg.engines) {
				pkg.engines = {};
			}
			pkg.engines.node = displayRange;
		},
	};
}

function isString(x) {
	return typeof x === 'string';
}

function getLatestMajors(versions, validRange = new Semver.Range('*')) {
	const versionsByMajor = versions.reduce((map, v) => {
		const major = Semver.major(v);
		const key = major === 0 ? `${major}.${Semver.minor(v)}` : String(major);
		if (!map[key]) {
			map[key] = [];
		}
		map[key].push(v);
		return map;
	}, {});
	return Object.values(versionsByMajor)
		.map((vs) => Semver.maxSatisfying(vs, validRange))
		.filter(isString)
		.sort((a, b) => -Semver.compare(a, b));
}

Promise.all([pAllVersions, graphRanges, pPackage]).then(async ([allVersions, graph, pkg]) => {
	const rootNode = (pkg.data.engines && pkg.data.engines.node) || '*';

	const rootValids = allVersions.node.filter((v) => Semver.satisfies(v, rootNode));
	const graphAllowed = graph.map(([n, r]) => [
		n,
		allVersions.node.filter((v) => Semver.satisfies(v, r)),
	]);
	const graphValids = graph.length > 0 ? intersect(graphAllowed.map(([, vs]) => vs)) : allVersions.node;
	const validMajorRanges = graph.length > 0 ? graphValids.reduceRight((prev, v) => {
		prev = [].concat(prev);
		return Semver.satisfies(v, caret(prev[prev.length - 1])) ? prev : prev.concat(v);
	}).map(caret) : ['*'];
	const validRange = new Semver.Range(validMajorRanges.join(' || '));
	if (!graphValids.every((v) => validRange.test(v))) {
		throw new RangeError(`please report this: ${graphValids.join(',')} / ${validRange}`);
	}
	// console.log('*', graphAllowed.filter(([x, vs]) => !vs.some((v) => v.startsWith('v14'))));

	const displayRange = validRange.raw && validRange.raw.replace(/(?:\.0)+(?<x> |$)/g, '$<x>').split(' ').reverse().join(' ');
	if (validRange.raw) {
		console.log(colors.gray(`\nValid node version range: ${displayRange}`));
		const latestMajors = getLatestMajors(allVersions.node, validRange);
		console.log(colors.bold(colors.gray(`\nCurrently available latest releases of each valid node major version: ${latestMajors.join(', ')}`)));
	}

	// TODO: refactor to make rootValids/graphValids an object of engines
	const pEngines = checkEngines(rootNode, { node: rootValids }, { node: graphValids }, { node: graphAllowed }, displayRange, save);

	// TODO: refactor to make rootValids/graphValids an object of engines
	const pCurrent = current ? checkCurrent(selectedEngines, { node: rootValids }, { node: graphValids }) : { output: [] };

	// print out successes first
	const results = await Promise.allSettled([pEngines, pCurrent]);
	const fulfilleds = results.filter(({ status }) => status === 'fulfilled');
	const rejecteds = results.filter(({ status }) => status === 'rejected');

	fulfilleds.reduce(async (prev, { value: { output, save: doSave } }) => {
		await prev;

		output.forEach((line) => {
			console.log(line);
		});
		if (save && doSave) {
			doSave(pkg.data);
			try {
				await pkg.save();
			} catch {
				process.exitCode |= EXITS.SAVE;
			}
		}
	}, Promise.resolve());

	// print out failures last
	await rejecteds.reduce(async (prev, error) => {
		await prev;

		if (!error || !error.reason) {
			throw error;
		}
		const { reason } = error;
		const { code, output, save: doSave } = reason;
		if (!output) {
			throw reason;
		}

		if (save && doSave) {
			doSave(pkg.data);
			try {
				await pkg.save();
			} catch {
				process.exitCode |= EXITS.SAVE;
			}
		} else {
			process.exitCode |= code;
		}
		output.forEach((line) => {
			console.error(line);
		});
	}, Promise.resolve());
}).catch((e) => {
	console.error((e && e.stack) || e);
	process.exitCode |= EXITS.ERROR;
});
