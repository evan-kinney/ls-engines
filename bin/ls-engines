#!/usr/bin/env node

'use strict';

const Semver = require('semver');
const { default: intersect } = require('fast_array_intersect');
const chalk = require('chalk');
const yargs = require('yargs');

const { argv: { mode } } = yargs
	.option('mode', {
		choices: ['auto', 'actual', 'virtual', 'ideal'],
		default: 'auto',
		describe: '”actual“ reads from `node_modules`; ”virtual“ reads from a lockfile; “ideal” reads from `package.json`',
	})
/*
	.option('only', {
		choices: ['production', 'dev'],
		describe: 'include only production, or only dev, deps'
	})
*/
	.strict()
	.help();

const getTree = require('../get-tree');
const getNodeVersions = require('../get-node-versions');

const pNameRanges = getTree(mode).then(async (tree) => {
	const tuples = [[tree.package.name, tree.package.engines && tree.package.engines.node]].concat(
		Array.from(
			tree.inventory.filter(({ package: { engines } }) => engines && engines.node),
			({ name, package: { engines: { node } } }) => [name, node],
		),
	).filter((x) => x && x[1]);
	return tuples
		.filter(([, node]) => node !== '*')
		.map(([name, node]) => [name, new Semver.Range(node)]);
});

function caret(ver) {
	return '^' + ver.replace(/^v/g, '');
}

Promise.all([getNodeVersions(), pNameRanges]).then(([nodeVersions, nameRanges]) => {
	const allowedVersions = nameRanges.map(([n, r]) => [
		n,
		nodeVersions.filter((v) => r.test(v)),
	]);
	const valids = nameRanges.length > 0 ? intersect(allowedVersions.map(([, vs]) => vs)) : nodeVersions;
	const validMajorRanges = nameRanges.length > 0 ? valids.reduceRight((prev, v) => {
		prev = [].concat(prev); // eslint-disable-line no-param-reassign
		return Semver.satisfies(v, caret(prev[prev.length - 1])) ? prev : prev.concat(v);
	}).map(caret) : ['*'];
	const validRange = new Semver.Range(validMajorRanges.join(' || '));
	if (!valids.every((v) => validRange.test(v))) {
		throw new RangeError('please report this: ' + valids.join(',') + ' / ' + validRange);
	}
	if (validRange.raw) {
		const displayRange = validRange.raw.replace(/(\.0)+( |$)/g, '$2').split(' ').reverse().join(' ');
		console.log(chalk.gray(`\nValid node version range: ${displayRange}`));
		const latestMajors = validMajorRanges.map((r) => Semver.maxSatisfying(nodeVersions, r).replace(/(\.0)+$/, '')).reverse();
		console.log(chalk.bold(chalk.gray(`\nCurrently available, most recent, valid node major versions: ${latestMajors.join(', ')}`)));
	}
	const currentValid = valids.includes(process.version);
	console.log(`\nCurrent node version, ${chalk.blue(chalk.bold(process.version))}, is ${chalk.bold(currentValid ? chalk.greenBright('valid') : chalk.red('invalid'))}!`);
	process.exitCode = currentValid ? 0 : 1;
}).catch((e) => {
	console.error(e.stack);
	process.exitCode = 2;
});
